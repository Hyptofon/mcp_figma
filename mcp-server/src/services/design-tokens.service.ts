// ─── Design Tokens Extractor ───
// Walks an IR tree, collects all unique colors/gradients,
// and produces CSS custom-property declarations for global.css.

import type { IRNode, IRColor, IRFill, IRGradientStop } from '../types/ir.types.js';

// ─── Public types ───

export interface DesignToken {
    varName: string;           // e.g. '--figma-bg-1'
    value: string;             // e.g. '#1A2B3C' or 'linear-gradient(...)'
    hex?: string;              // hex key for lookup (colors only)
    type: 'color' | 'gradient';
}

/** hex (lowercase, no #) → CSS var name */
export type TokenMap = Map<string, string>;

// ─── Service ───

export class DesignTokensService {

    private colorIndex = 0;
    private gradientIndex = 0;
    private nameCounts = new Map<string, number>();

    private getSemanticColorName(r: number, g: number, b: number): string {
        // Convert to HSL for better naming
        const rNorm = r / 255;
        const gNorm = g / 255;
        const bNorm = b / 255;
        const max = Math.max(rNorm, gNorm, bNorm);
        const min = Math.min(rNorm, gNorm, bNorm);
        let h = 0, s = 0, l = (max + min) / 2;

        if (max !== min) {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case rNorm: h = (gNorm - bNorm) / d + (gNorm < bNorm ? 6 : 0); break;
                case gNorm: h = (bNorm - rNorm) / d + 2; break;
                case bNorm: h = (rNorm - gNorm) / d + 4; break;
            }
            h /= 6;
        }

        const hue = Math.round(h * 360);
        const sat = Math.round(s * 100);
        const lit = Math.round(l * 100);

        // Neutrals
        if (lit >= 95) return 'white';
        if (lit <= 12) return 'black';
        if (sat <= 15) return 'gray';
        // Low saturation blues/purples usually map to slate
        if (sat <= 25 && hue >= 200 && hue <= 260) return 'slate';

        // Colors
        if (hue < 15 || hue >= 345) return 'red';
        if (hue >= 15 && hue < 45) return 'orange';
        if (hue >= 45 && hue < 75) return 'yellow';
        if (hue >= 75 && hue < 160) return 'green';
        if (hue >= 160 && hue < 200) return 'cyan';
        if (hue >= 200 && hue < 260) return 'blue';
        if (hue >= 260 && hue < 290) return 'purple';
        if (hue >= 290 && hue < 345) return 'pink';

        return 'primary';
    }

    private getUniqueName(baseName: string): string {
        const count = this.nameCounts.get(baseName) || 0;
        this.nameCounts.set(baseName, count + 1);
        return count === 0 ? baseName : `${baseName}-${count + 1}`;
    }

    /**
     * Extract all unique colors and gradients from the IR tree.
     * Returns the list of tokens AND a lookup map (hex → var name).
     */
    extract(root: IRNode): { tokens: DesignToken[]; tokenMap: TokenMap } {
        const colorSet = new Map<string, DesignToken>();   // hex → token
        const gradientSet: DesignToken[] = [];
        const gradientSignatures = new Set<string>();

        this.walk(root, colorSet, gradientSet, gradientSignatures);

        const tokens = [...colorSet.values(), ...gradientSet];
        const tokenMap: TokenMap = new Map();
        for (const t of colorSet.values()) {
            if (t.hex) tokenMap.set(t.hex, t.varName);
        }

        return { tokens, tokenMap };
    }

    /**
     * Generate the CSS string for a :root { ... } block with all tokens.
     */
    generateCss(tokens: DesignToken[]): string {
        if (tokens.length === 0) return '';

        const lines = tokens.map(t => `    ${t.varName}: ${t.value};`);
        return `/* ─── Auto-generated Figma Design Tokens ─── */\n/* Do not edit manually — regenerated by generate.ts */\n\n:root {\n${lines.join('\n')}\n}\n`;
    }

    // ─── Private helpers ───

    private walk(
        node: IRNode,
        colors: Map<string, DesignToken>,
        gradients: DesignToken[],
        gradSigs: Set<string>,
    ): void {
        // Collect fills
        for (const fill of node.fills) {
            this.processFill(fill, colors, gradients, gradSigs);
        }

        // Collect border colors
        for (const border of node.borders) {
            this.addColor(border.color, colors);
        }

        // Collect text color (first solid fill on text nodes)
        if (node.componentType === 'text' && node.fills.length > 0) {
            const solidFill = node.fills.find(f => f.type === 'solid' && f.color);
            if (solidFill?.color) {
                this.addColor(solidFill.color, colors);
            }
        }

        // Recurse into children
        for (const child of node.children) {
            this.walk(child, colors, gradients, gradSigs);
        }
    }

    private processFill(
        fill: IRFill,
        colors: Map<string, DesignToken>,
        gradients: DesignToken[],
        gradSigs: Set<string>,
    ): void {
        if (fill.type === 'solid' && fill.color) {
            this.addColor(fill.color, colors);
        } else if (
            (fill.type === 'gradient-linear' || fill.type === 'gradient-radial') &&
            fill.gradientStops?.length
        ) {
            this.addGradient(fill, gradients, gradSigs);
        }
    }

    private addColor(color: IRColor, colors: Map<string, DesignToken>): void {
        const hex = color.hex.replace('#', '').toLowerCase();
        if (colors.has(hex)) return;

        // Skip fully transparent
        if (color.a <= 0) return;

        this.colorIndex++;
        const baseName = this.getSemanticColorName(color.r, color.g, color.b);
        const uniqueName = this.getUniqueName(baseName);
        const varName = `--color-${uniqueName}`;

        const value = color.a < 1
            ? `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a.toFixed(2)})`
            : color.hex;

        colors.set(hex, { varName, value, hex, type: 'color' });
    }

    private addGradient(
        fill: IRFill,
        gradients: DesignToken[],
        gradSigs: Set<string>,
    ): void {
        const stops = fill.gradientStops!;
        const sig = stops.map(s => `${s.color.hex}@${s.position.toFixed(2)}`).join(',');
        if (gradSigs.has(sig)) return;
        gradSigs.add(sig);

        const varName = `--gradient-${this.getUniqueName('background')}`;
        const cssStops = stops
            .map(s => `${s.color.hex} ${Math.round(s.position * 100)}%`)
            .join(', ');

        const value = fill.type === 'gradient-linear'
            ? `linear-gradient(${fill.gradientAngle ?? 180}deg, ${cssStops})`
            : `radial-gradient(${cssStops})`;

        gradients.push({ varName, value, type: 'gradient' });
    }
}
